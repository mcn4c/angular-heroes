{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component } from '@angular/core';\nlet HeroesComponent = class HeroesComponent {\n  //the parameter simultaneously defines a private heroService property and identifies it as a HeroService\n  //injection site\n  //When angular creates a HeroesComponent, the dependency injection system sets the heroService parameter \n  //to the singleton instance of HeroService\n  constructor(heroService) {\n    this.heroService = heroService;\n    this.heroes = [];\n  } //ngOnIt is a lifecycle hook.  Angular calls ngOnIt shortly after creating a component\n  //it's a good place to put initialization logic\n\n\n  ngOnInit() {\n    this.getHeroes();\n  } //Observable.subscribe for when making request to remote server\n  //waits for observvable to emit the array of heroes - which could happen now\n  //or several minutes from now\n  //the subscribe() method passes the emitted array to the callback, which sets the component's\n  //heroes property\n  //asynchronous approach\n\n\n  getHeroes() {\n    this.heroService.getHeroes().subscribe(heroes => this.heroes = heroes);\n  } //When given name is non-blank the handler creates a hero-like object from the name(it's only missing Id)\n  //and passes it into the services addHero() method\n  //When addHero() saves successfully, the subscribe() callback receives the new hero and pushes it into \n  //the heroes list for display\n  //addHero() differes from update hero in two ways:\n  //it calls HttpClient.post() instead of put()\n  // it expects the server to generate an id for the new hero, which it returns \n  //in the Observable<Hero> to the caller\n\n\n  add(name) {\n    name = name.trim();\n\n    if (!name) {\n      return;\n    }\n\n    this.heroService.addHero({\n      name\n    }).subscribe(hero => {\n      this.heroes.push(hero);\n    });\n  }\n\n};\nHeroesComponent = __decorate([Component({\n  selector: 'app-heroes',\n  templateUrl: './heroes.component.html',\n  styleUrls: ['./heroes.component.css']\n})], HeroesComponent);\nexport { HeroesComponent };","map":{"version":3,"sources":["C:/Users/MNash/Desktop/angular-heroes/src/app/heroes/heroes.component.ts"],"names":["__decorate","Component","HeroesComponent","constructor","heroService","heroes","ngOnInit","getHeroes","subscribe","add","name","trim","addHero","hero","push","selector","templateUrl","styleUrls"],"mappings":"AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,SAASC,SAAT,QAA0B,eAA1B;AACA,IAAIC,eAAe,GAAG,MAAMA,eAAN,CAAsB;AACxC;AACA;AACA;AACA;AACAC,EAAAA,WAAW,CAACC,WAAD,EAAc;AACrB,SAAKA,WAAL,GAAmBA,WAAnB;AACA,SAAKC,MAAL,GAAc,EAAd;AACH,GARuC,CASxC;AACA;;;AACAC,EAAAA,QAAQ,GAAG;AACP,SAAKC,SAAL;AACH,GAbuC,CAcxC;AACA;AACA;AACA;AACA;AACA;;;AACAA,EAAAA,SAAS,GAAG;AACR,SAAKH,WAAL,CAAiBG,SAAjB,GACKC,SADL,CACeH,MAAM,IAAI,KAAKA,MAAL,GAAcA,MADvC;AAEH,GAvBuC,CAwBxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAI,EAAAA,GAAG,CAACC,IAAD,EAAO;AACNA,IAAAA,IAAI,GAAGA,IAAI,CAACC,IAAL,EAAP;;AACA,QAAI,CAACD,IAAL,EAAW;AACP;AACH;;AACD,SAAKN,WAAL,CAAiBQ,OAAjB,CAAyB;AAAEF,MAAAA;AAAF,KAAzB,EACKF,SADL,CACeK,IAAI,IAAI;AACnB,WAAKR,MAAL,CAAYS,IAAZ,CAAiBD,IAAjB;AACH,KAHD;AAIH;;AAzCuC,CAA5C;AA2CAX,eAAe,GAAGF,UAAU,CAAC,CACzBC,SAAS,CAAC;AACNc,EAAAA,QAAQ,EAAE,YADJ;AAENC,EAAAA,WAAW,EAAE,yBAFP;AAGNC,EAAAA,SAAS,EAAE,CAAC,wBAAD;AAHL,CAAD,CADgB,CAAD,EAMzBf,eANyB,CAA5B;AAOA,SAASA,eAAT","sourcesContent":["import { __decorate } from \"tslib\";\r\nimport { Component } from '@angular/core';\r\nlet HeroesComponent = class HeroesComponent {\r\n    //the parameter simultaneously defines a private heroService property and identifies it as a HeroService\r\n    //injection site\r\n    //When angular creates a HeroesComponent, the dependency injection system sets the heroService parameter \r\n    //to the singleton instance of HeroService\r\n    constructor(heroService) {\r\n        this.heroService = heroService;\r\n        this.heroes = [];\r\n    }\r\n    //ngOnIt is a lifecycle hook.  Angular calls ngOnIt shortly after creating a component\r\n    //it's a good place to put initialization logic\r\n    ngOnInit() {\r\n        this.getHeroes();\r\n    }\r\n    //Observable.subscribe for when making request to remote server\r\n    //waits for observvable to emit the array of heroes - which could happen now\r\n    //or several minutes from now\r\n    //the subscribe() method passes the emitted array to the callback, which sets the component's\r\n    //heroes property\r\n    //asynchronous approach\r\n    getHeroes() {\r\n        this.heroService.getHeroes()\r\n            .subscribe(heroes => this.heroes = heroes);\r\n    }\r\n    //When given name is non-blank the handler creates a hero-like object from the name(it's only missing Id)\r\n    //and passes it into the services addHero() method\r\n    //When addHero() saves successfully, the subscribe() callback receives the new hero and pushes it into \r\n    //the heroes list for display\r\n    //addHero() differes from update hero in two ways:\r\n    //it calls HttpClient.post() instead of put()\r\n    // it expects the server to generate an id for the new hero, which it returns \r\n    //in the Observable<Hero> to the caller\r\n    add(name) {\r\n        name = name.trim();\r\n        if (!name) {\r\n            return;\r\n        }\r\n        this.heroService.addHero({ name })\r\n            .subscribe(hero => {\r\n            this.heroes.push(hero);\r\n        });\r\n    }\r\n};\r\nHeroesComponent = __decorate([\r\n    Component({\r\n        selector: 'app-heroes',\r\n        templateUrl: './heroes.component.html',\r\n        styleUrls: ['./heroes.component.css']\r\n    })\r\n], HeroesComponent);\r\nexport { HeroesComponent };\r\n"]},"metadata":{},"sourceType":"module"}